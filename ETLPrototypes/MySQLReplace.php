<?php
namespace axenox\ETL\ETLPrototypes;

use exface\Core\Exceptions\RuntimeException;
use axenox\ETL\Common\Traits\SqlIncrementalWhereTrait;
use axenox\ETL\Common\Traits\SqlColumnMappingsTrait;
use axenox\ETL\Interfaces\ETLStepResultInterface;

/**
 * Executes a REPLACE statement on a MySQL data source.
 * 
 * You can either use the autogenerated REPLACE statement and the `column_mappings` or
 * define a custom `sql` using placeholders.
 * 
 * The default statement is:
 * 
 * ```
 *  REPLACE INTO [#to_object_address#] 
 *    ([#columns#]) 
 *    SELECT 
 *        [#selects#] 
 *    FROM [#from_object_address#]
 *    WHERE [#incremental_where#];
 *    
 * ```
 * 
 * If you need an incremental step, use a custom `sql` with additional placeholders for
 * `[#last_run_increment_value#]`, etc. 
 * 
 * **WARNING:** MySQL REPLACE only works well if you know the primary keys of the to-object.
 * In other words, you MUST have the primary key of the to-object in the `to` value of one
 * of your `column_mappings`. In other cases use `MySQLInsertOnDuplicateKeyUpdate` instead!
 * 
 * Technically it would also work with a unique index on other columns, but that would cause
 * the primary keys with AUTO_INCREMENT to get regenerated with every replacement!!!
 * 
 * @author Andrej Kabachnik
 * 
 * @see MySQLInsertOnDuplicateKeyUpdate
 *
 */
class MySQLReplace extends SQLRunner
{
    use SqlIncrementalWhereTrait; 
    use SqlColumnMappingsTrait;
    
    /**
     * 
     * {@inheritDoc}
     * @see \axenox\ETL\ETLPrototypes\SQLRunner::getSql()
     */
    protected function getSql() : string
    {
        if ($customSql = parent::getSql()) {
            return $customSql;
        }
        
        return <<<SQL

REPLACE INTO [#to_object_address#] 
    ([#columns#]) 
    SELECT 
        [#selects#] 
    FROM [#from_object_address#]
    WHERE [#incremental_where#];

SQL;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \axenox\ETL\ETLPrototypes\SQLRunner::getPlaceholders()
     */
    protected function getPlaceholders(string $flowRunUid, string $stepRunUid, ETLStepResultInterface $lastResult = null) : array
    {
        $targetCols = '';
        $sourceCols = '';
        
        foreach ($this->getColumnMappings() as $map) {
            $targetCols .= ($targetCols ? ', ' : '') . $map->getToSql();
            $sourceCols .= ($sourceCols ? ', ' : '') . $map->getFromSql();
        }
        
        if ($targetCols === '' || $sourceCols === '') {
            throw new RuntimeException('Cannot run ETL step "' . $this->getName() . '": no `column_mappings` defined!');
        }
        
        if (null !== $runUidAlias = $this->getStepRunUidAttributeAlias()) {
            $targetCols .= ', ' . $this->getToObject()->getAttribute($runUidAlias)->getDataAddress();
            $sourceCols .= ', [#step_run_uid#]';
        }
        
        if (null !== $flowRunUidAlias = $this->getFlowRunUidAttributeAlias()) {
            $targetCols .= ', ' . $this->getToObject()->getAttribute($flowRunUidAlias)->getDataAddress();
            $sourceCols .= ', [#flow_run_uid#]';
        }
        
        return array_merge(parent::getPlaceholders($flowRunUid, $stepRunUid, $lastResult), [
            'columns' => $targetCols,
            'selects' => $sourceCols,
            'incremental_where' => $this->getSqlIncrementalWhere() ?? '(1=1)'
        ]);
    }
}